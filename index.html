<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-title" content="SYNTH*BLAST"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1"/>
    <meta name="format-detection" content="telephone=no"/>
    <link rel="apple-touch-icon" sizes="150x150" href="assets/img/apple-touch-icon.png">
    <title>S Y N T H * B L A S T</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            position: fixed;
            /*https://stackoverflow.com/questions/15829172/stop-chrome-back-forward-two-finger-swipe*/
            overscroll-behavior-x: none;
            background-color: #000000;
        }

        canvas {
            width: 100%;
            height: 100%;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            outline: none;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0); /* mobile webkit */
        }

        @font-face {
            font-family: 'kenpixel';
            src: url("assets/fonts/kenpixel.ttf");
        }

    </style>
</head>
<body>
<script src='node_modules/stats.js/build/stats.min.js'></script>
<script src='lib/pixi.min.js'></script>
<script type="module">


    // make synthwave background (syntywave sunset)
    // skybox: https://threejsfundamentals.org/threejs/lessons/threejs-backgrounds.html
    // skybox SO: https://stackoverflow.com/questions/45443196/how-to-set-up-image-background-in-three-js
    // https://videohive.net/item/80s-synthwave-retro-hd/24080448

    // levels

    // points display

    // point pad

    // add shooting stars

    // make guns things you can pick up

    // have to be facing an enemy to shoot them

    // add UI elements: health bar

    // see where blasts hit buildings:
    // https://stackoverflow.com/questions/11586527/converting-world-coordinates-to-screen-coordinates-in-three-js-using-projection


    // libraries
    import * as THREE from "./lib/three/build/three.module.js";
    import * as Utils from "./js/Utils.js";

    // Three.js classes
    import {EffectComposer} from './lib/three/examples/jsm/postprocessing/EffectComposer.js';
    import {RenderPass} from './lib/three/examples/jsm/postprocessing/RenderPass.js';
    import {GlitchPass} from './js/CustomGlitchPass.js';

    // my classes
    import Hero from "./js/classes/Hero.js";
    import Building from "./js/classes/Building.js";
    import Gun from "./js/classes/Gun.js";
    import Enemy from "./js/classes/Enemy.js";
    import Flipper from "./js/classes/powerups/Flipper.js";

    // three objects
    let scene, camera, rendererThree, composer, glitchPass;

    // pixi objects
    let rendererPixi, pixiStage;
    let instructionText, statusText, finalText;
    let b1, b2, b3, b4, b6, b7, b8, b9, bFire;
    let bWidth = 60;

    let hero = null;
    let bullets = [];
    let buildings = [];
    let enemies = [];
    let powerUps = [];
    let gun = null;
    let padsRemaining = 0;

    let arenaSize = 50;

    // Sounds
    // let massive = new Audio('assets/audio/massive2.wav');
    let song = new Audio('music/implant-128kbps.mp3');
    let pew = new Audio('assets/audio/pip.wav');
    let pointSound = new Audio('assets/audio/point.wav');
    let hitSound = new Audio('assets/audio/hit.wav');
    let explosionSound = new Audio('assets/audio/explosion2.wav');
    let impactSound = new Audio('assets/audio/impact.wav');
    let audiosWeWantToUnlock = [pew, hitSound, explosionSound, song];

    let frameCount = 0;
    let frameTimes = [];
    let fpsAdjustment = 1;

    // Music
    // let song = new Audio('music/implant-128kbps.mp3');
    // song.crossOrigin = "anonymous";

    // State
    let hasStarted = false;
    let isSongPlaying = false;

    // stats
    let stats = new Stats();
    stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
    document.body.appendChild(stats.dom);

    init();
    animate();

    function animate() {
        stats.begin();
        rendererThree.state.reset();
        render3d();
        rendererThree.state.reset();

        rendererPixi.reset();
        render2d();
        rendererPixi.reset();

        calculateFps();
        stats.end();
        requestAnimationFrame(animate);
    }

    function calculateFps() {
        frameCount++;
        if (frameCount < 10) {
            frameTimes.push((new Date()).getTime());
        } else {
            let frameIndex = frameCount % 10;
            let now = (new Date()).getTime();
            let then = frameTimes[frameIndex];
            frameTimes[frameIndex] = now;
            let fps = 10.0 / ((now - then) / 1000);
            if (fps > 1) {
                fpsAdjustment = 60 / fps;
            }
        }
    }


    function init() {
        let canvas = document.getElementById("screen");
        rendererThree = new THREE.WebGLRenderer({
            canvas: canvas
        });
        rendererPixi = new PIXI.Renderer({
            view: canvas,
            context: rendererThree.getContext()
        });
        pixiStage = new PIXI.Container();

        init3d();
        init2d();

        // listeners
        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('keydown', onDocumentKeyDown, false);
        document.addEventListener('keyup', onDocumentKeyUp, false);
        document.addEventListener('touchstart', touchStart, {passive: false});
        document.addEventListener('touchend', touchEnd, {passive: false});
        document.body.addEventListener('touchmove', touchStart, {passive: false});
    }

    function init2d() {
        let isMobile = 'ontouchstart' in document.documentElement;
        if (isMobile) {
            let half = bWidth / 2;
            let offset = 10;
            let x0 = offset;
            let x1 = bWidth + offset;
            let x2 = bWidth * 2 + offset;
            let x3 = bWidth * 3 + offset;
            let y1 = window.innerHeight - bWidth * 3 - offset;
            let y2 = window.innerHeight - bWidth * 2 - offset;
            let y3 = window.innerHeight - bWidth - offset;
            let y4 = window.innerHeight - offset;

            // squares
            b1 = getSquare(x0, y1, bWidth);
            pixiStage.addChild(b1);
            b2 = getSquare(x1, y1, bWidth);
            pixiStage.addChild(b2);
            b3 = getSquare(x2, y1, bWidth);
            pixiStage.addChild(b3);

            b4 = getSquare(x0, y2, bWidth);
            pixiStage.addChild(b4);
            b6 = getSquare(x2, y2, bWidth);
            pixiStage.addChild(b6);

            b7 = getSquare(x0, y3, bWidth);
            pixiStage.addChild(b7);
            b8 = getSquare(x1, y3, bWidth);
            pixiStage.addChild(b8);
            b9 = getSquare(x2, y3, bWidth);
            pixiStage.addChild(b9);

            bFire = new PIXI.Graphics();
            bFire.beginFill(0xFF00FF);
            bFire.drawEllipse(window.innerWidth - (bWidth * 1.5), window.innerHeight - (bWidth * 1.5), bWidth, bWidth);
            bFire.alpha = 0.6;
            bFire.visible = false; // initially hidden
            pixiStage.addChild(bFire);

            let fireOutline = new PIXI.Graphics();
            fireOutline.lineStyle(2, 0xCC88CC, 1);
            fireOutline.drawEllipse(window.innerWidth - (bWidth * 1.5), window.innerHeight - (bWidth * 1.5), bWidth, bWidth);
            pixiStage.addChild(fireOutline);

            // grid
            let gridThickness = 2;
            drawLine(x0, y1, x3, y1, gridThickness);
            drawLine(x0, y2, x3, y2, gridThickness);
            drawLine(x0, y3, x3, y3, gridThickness);
            drawLine(x0, y4, x3, y4, gridThickness);
            drawLine(x0, y1, x0, y4, gridThickness);
            drawLine(x1, y1, x1, y4, gridThickness);
            drawLine(x2, y1, x2, y4, gridThickness);
            drawLine(x3, y1, x3, y4, gridThickness);
            //arrows
            drawArrow(x0 + half, y1 + half, Math.PI * -.25);
            drawArrow(x1 + half, y1 + half, 0);
            drawArrow(x2 + half, y1 + half, Math.PI * .25);
            drawArrow(x0 + half, y2 + half, Math.PI * -.5);
            drawArrow(x2 + half, y2 + half, Math.PI * .5);
            drawArrow(x0 + half, y3 + half, Math.PI * -.75);
            drawArrow(x1 + half, y3 + half, Math.PI * -1);
            drawArrow(x2 + half, y3 + half, Math.PI * -1.25);
        } else {
            // https://stackoverflow.com/questions/55692097/stop-pixel-font-from-being-blurred-when-rendered
            let instructionStyle = new PIXI.TextStyle({
                fontFamily: "kenpixel, \"Courier New\", Courier, monospace",
                fontSize: 14,
                fill: "#00FFFF",
                stroke: '#ff00FF',
                strokeThickness: 1,
                dropShadow: true,
                dropShadowColor: "#000000",
                dropShadowBlur: 2,
                dropShadowAngle: 0,
                dropShadowDistance: 0,
            });

            instructionText = new PIXI.Text('ARROW KEYS TO MOVE; SPACE TO FIRE.', instructionStyle);
            instructionText.position.set(10, window.innerHeight - 50);
            pixiStage.addChild(instructionText);
        }

        let statusStyle = new PIXI.TextStyle({
            fontFamily: "kenpixel, \"Courier New\", Courier, monospace",
            fontSize: 18,
            fill: "#99DDDD",
        });

        statusText = new PIXI.Text("", statusStyle);
        statusText.position.set(10, 50);
        pixiStage.addChild(statusText);

        let finalStyle = new PIXI.TextStyle({
            fontFamily: "kenpixel, \"Courier New\", Courier, monospace",
            fontSize: 48,
            fill: "#99FFFF",
            align: "center"
        });

        finalText = new PIXI.Text("", finalStyle);
        finalText.position.set(window.innerWidth / 2, window.innerHeight / 2);
        pixiStage.addChild(finalText);
    }

    function getSquare(x, y, width) {
        let square = new PIXI.Graphics();
        square.beginFill(0xFF00FF);
        square.drawRect(x, y, width, width);
        square.alpha = 0.6;
        square.visible = false; // initially hidden
        return square;
    }

    function drawLine(x1, y1, x2, y2, thickness) {
        pixiStage.addChild(getLine(x1, y1, x2, y2, thickness));
    }

    function getLine(x1, y1, x2, y2, thickness) {
        let line = new PIXI.Graphics();
        line.lineStyle(thickness, 0xCC88CC, 1);
        line.moveTo(x1, y1);
        line.lineTo(x2, y2);
        return line;
    }

    function drawArrow(x, y, rotation) {
        const container = new PIXI.Container();
        let l = 10;
        let thickness = 2;
        container.addChild(getLine(0, 5, 0, 0 - l, thickness));
        container.addChild(getLine(0, 0 - l, 0 - l, 0, thickness));
        container.addChild(getLine(0, 0 - l, l, 0, thickness));
        container.x = x;
        container.y = y;
        container.rotation = rotation;
        pixiStage.addChild(container);

    }

    function init3d() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 50);
        scene.background = new THREE.Color(0x000000);
        // scene.background = new THREE.Color(0xefd1b5);
        scene.fog = new THREE.FogExp2(0xFF00FF, 0.05);
        scene.color = 0x00DD00;

        rendererThree.setSize(window.innerWidth, window.innerHeight);

        composer = new EffectComposer(rendererThree);

        //hero = new Hero(scene, camera, -55, 0);

        hero = new Hero(scene, camera, 10, 0);
        // add buildings
        let halfArena = arenaSize / 2;
        for (let gridX = 0; gridX < arenaSize; gridX++) {
            for (let gridY = 0; gridY < arenaSize; gridY++) {
                if (gridY === halfArena) continue;
                // if (gridY % 3 === 0 || gridX % 3 === 0) continue;
                // if (!(gridY % 4 === 0 || gridY % 4 === 1 || gridX % 4 === 0 || gridX % 4 === 1)) {
                if (Utils.randomInt(40) === 0) {
                    let boxHeight = Utils.randomInt(10) + 1;
                    let building = new Building(gridX, gridY - halfArena, boxHeight, scene, true);
                    buildings.push(building);
                } else if (Utils.randomInt(40) === 0) {
                    let enemy = new Enemy(gridX, gridY - halfArena, scene, 1);
                    enemies.push(enemy);
                } else if (Utils.randomInt(160) === 0) {
                    let powerUp = new Flipper(gridX, gridY - halfArena, scene);
                    powerUps.push(powerUp);
                    padsRemaining += 1;
                }
            }
        }

        // add fence around the buildings
        for (let gridX = -1; gridX <= arenaSize; gridX++) {
            for (let gridY = -1; gridY <= arenaSize; gridY++) {
                // leaving a gap
                if (gridY === halfArena && gridX === -1) continue;
                // only filling in edges
                if (gridX === -1 || gridY === -1 || gridX === arenaSize || gridY === arenaSize) {
                    let boxHeight = 1;
                    // if (gridY % 2 === 0 || gridX % 2 === 0) boxHeight = 2;
                    if (gridX !== arenaSize && (gridY === halfArena - 1 || gridY === halfArena + 1)) boxHeight = 20;
                    let building = new Building(gridX, gridY - arenaSize / 2, boxHeight, scene, false);
                    buildings.push(building);
                }
            }
        }

        gun = new Gun(scene, bullets, hero, pew);
        hero.setGun(gun);

        // floor
        let floorTexture = new THREE.TextureLoader().load('assets/img/floor-tile.png');
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(1000, 1000);
        let floorMaterial = new THREE.MeshBasicMaterial({map: floorTexture, side: THREE.FrontSide});
        let floorGeometry = new THREE.PlaneGeometry(1000, 1000, 1, 1);
        let plane = new THREE.Mesh(floorGeometry, floorMaterial);
        plane.position.z = 0;
        scene.add(plane);

        // light
        let dirLight;
        dirLight = new THREE.DirectionalLight(0xffffff);
        dirLight.position.set(-2, 5, 3).normalize();
        scene.add(dirLight);

        // "synth blast" title
        addTitleImage();

        // post processing
        let renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        glitchPass = new GlitchPass();
        composer.addPass(glitchPass);
    }

    //https://codepen.io/duhaime/pen/jaYdLg
    function addTitleImage() {
        let loader = new THREE.TextureLoader();
        let material = new THREE.MeshLambertMaterial({
            map: loader.load('assets/img/synthblast.png'),
            fog: false
        });
        // preserve ratio
        let geometry = new THREE.PlaneGeometry(5 * 358 / 32, 5);
        let mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(-10, 0, 20);
        mesh.rotation.y = -Math.PI / 2;
        mesh.rotation.x = Math.PI / 2;
        scene.add(mesh);
    }

    function touchStart(event) {
        hasStarted = true;
        // if(audiosWeWantToUnlock) {
        //     for(let audio of audiosWeWantToUnlock) {
        //         audio.play();
        //         audio.pause();
        //         audio.currentTime = 0;
        //     }
        //     audiosWeWantToUnlock = null
        // }
        if (!isSongPlaying) {
            song.play();
        }
        down(event);
        event.stopImmediatePropagation();
        event.preventDefault();

    }

    function touchEnd(event) {
        for (let i = 0; i < event.changedTouches.length; i++) {
            let touch = event.changedTouches[i];
            if (touch.clientX < window.innerWidth / 2) {
                hero.stopTurning();
                hero.stop();
                b1.visible = false;
                b2.visible = false;
                b3.visible = false;
                b4.visible = false;
                b6.visible = false;
                b7.visible = false;
                b8.visible = false;
                b9.visible = false;
            } else {
                bFire.visible = false;
                hero.stopShooting();
            }
        }
    }

    function down(event) {
        for (let i = 0; i < event.touches.length; i++) {
            let touch = event.touches[i];
            let x = touch.clientX;
            let y = touch.clientY;
            let offset = 10;
            let x0 = 0;
            let x1 = bWidth + offset;
            let x2 = bWidth * 2 + offset;
            let x3 = bWidth * 4 + offset;
            let y1 = window.innerHeight - bWidth * 4 - offset;
            let y2 = window.innerHeight - bWidth * 2 - offset;
            let y3 = window.innerHeight - bWidth - offset;
            let y4 = window.innerHeight;

            if (x < x3 && y > y1) {
                b1.visible = false;
                b2.visible = false;
                b3.visible = false;
                b4.visible = false;
                b6.visible = false;
                b7.visible = false;
                b8.visible = false;
                b9.visible = false;

                if (x > x0 && x < x1 && y > y1 && y < y2) b1.visible = true;
                if (x > x1 && x < x2 && y > y1 && y < y2) b2.visible = true;
                if (x > x2 && x < x3 && y > y1 && y < y2) b3.visible = true;

                if (x > x0 && x < x1 && y > y2 && y < y3) b4.visible = true;
                if (x > x2 && x < x3 && y > y2 && y < y3) b6.visible = true;

                if (x > x0 && x < x1 && y > y3 && y < y4) b7.visible = true;
                if (x > x1 && x < x2 && y > y3 && y < y4) b8.visible = true;
                if (x > x2 && x < x3 && y > y3 && y < y4) b9.visible = true;
            }

            // check that we're in the control box
            if (x < x3 && y > y1) {
                if (x < x1) {
                    hero.turnLeft();
                }
                if (x > x1 && x < x2) {
                    hero.stopTurning();
                }
                if (x > x2) {
                    hero.turnRight();
                }
                if (y < y2) {
                    hero.forward();
                }
                if (y > y2 && y < y3) {
                    hero.stop();
                }
                if (y > y3) {
                    hero.reverse();
                }
            }

            if (x > window.innerWidth - 3 * bWidth) {
                hero.startShooting();
                bFire.visible = true;
            }
        }

    }

    function onDocumentKeyDown(event) {
        hasStarted = true;
        if (!isSongPlaying) {
            song.play();
        }
        let keyCode = event["which"];
        if (event.shiftKey) {
            hero.changePerspective();
        } else if (keyCode === 32) {
            hero.startShooting();
        } else if (keyCode === 37) {
            hero.turnLeft();
        } else if (keyCode === 38) {
            hero.forward();
        } else if (keyCode === 39) {
            hero.turnRight();
        } else if (keyCode === 40) {
            hero.reverse();
        }
        pixiStage.removeChild(instructionText);
    }

    function onDocumentKeyUp(event) {
        let keyCode = event["which"];
        if (keyCode === 32) {
            hero.stopShooting();
        } else if (keyCode === 37) {
            hero.stopTurning();
        } else if (keyCode === 38) {
            hero.stop();
        } else if (keyCode === 39) {
            hero.stopTurning();
        } else if (keyCode === 40) {
            hero.stop();
        }
    }

    function render3d() {

        // update our objects
        bullets.forEach(bullet => bullet.update());
        buildings.forEach(building => building.update(fpsAdjustment));
        enemies.forEach(enemy => enemy.update(hero, fpsAdjustment));
        powerUps.forEach(powerUp => powerUp.update(fpsAdjustment));
        hero.update(fpsAdjustment);

        // bullets hitting things
        bullets.forEach(bullet => {
            if (bullet.isActive()) {
                buildings.forEach(building => {
                    if (
                        building.isActive()
                        && Math.abs(building.getX() - bullet.getX()) < 0.5
                        && Math.abs(building.getY() - bullet.getY()) < 0.5
                    ) {
                        let buildingHitPoints = building.getHitPoints();
                        building.hit(bullet.getHitPoints());
                        bullet.hit(buildingHitPoints);
                        impactSound.currentTime = 0;
                        impactSound.play();

                    }
                });
                enemies.forEach(enemy => {
                    if (
                        enemy.isAlive()
                        && Math.abs(enemy.getX() - bullet.getX()) < 0.5
                        && Math.abs(enemy.getY() - bullet.getY()) < 0.5
                    ) {
                        let enemyHitPoints = enemy.getHitPoints();
                        enemy.hit(bullet.getHitPoints(), fpsAdjustment);
                        bullet.hit(enemyHitPoints);
                        if (!enemy.isAlive()) {
                            explosionSound.currentTime = 0;
                            explosionSound.play();
                        } else {
                            impactSound.currentTime = 0;
                            impactSound.play();
                        }
                    }
                });

            }
        });

        // can't go through buildings
        buildings.forEach(building => {
            if (building.isActive()) {
                if (
                    Math.abs(building.getX() - hero.getX()) < 0.6
                    && Math.abs(building.getY() - hero.getY()) < 0.6
                ) {
                    // getting them out of the building
                    hero.unMove();
                }
                enemies.forEach(
                    enemy => {
                        if (
                            enemy.isAlive()
                            && Math.abs(enemy.getX() - building.getX()) < 0.6
                            && Math.abs(enemy.getY() - building.getY()) < 0.6
                        ) {
                            enemy.unMove();
                        }
                    });
            }
        });

        if (hero.isAlive()) {
            let heroR = 0.4;
            if (hero.hasShield()) heroR = 1.5;
            enemies.forEach(
                enemy => {
                    if (
                        enemy.isAlive()
                        && Math.abs(enemy.getX() - hero.getX()) < heroR
                        && Math.abs(enemy.getY() - hero.getY()) < heroR
                    ) {

                        let heroHitPoints = hero.getHitPoints();
                        let damage = hero.hit(enemy.getHitPoints());
                        enemy.hit(heroHitPoints, fpsAdjustment);
                        // hero.reset();
                        if (damage > 0) {
                            glitchPass.trigger();
                        }
                        if (enemy.isAlive()) {
                            hitSound.currentTime = 0;
                            hitSound.play();
                        } else {
                            explosionSound.currentTime = 0;
                            explosionSound.play();
                        }
                    }
                });

            powerUps.forEach(pad => {
                if (
                    !pad.isUsed
                    && Math.abs(pad.getX() - hero.getX()) < 0.7
                    && Math.abs(pad.getY() - hero.getY()) < 0.7
                ) {
                    pad.hit();
                    padsRemaining -= 1;
                    pointSound.currentTime = 0;
                    pointSound.play();
                }
            });
        }

        composer.render();
    }

    function render2d() {
        if (padsRemaining === 0) {
            finalText.text = "YOU WIN";
            finalText.x = (window.innerWidth - finalText.width) / 2;
            statusText.text = "";
        } else if (hero.hitPoints <= 0) {
            finalText.text = "TRY AGAIN";
            finalText.x = (window.innerWidth - finalText.width) / 2;
            statusText.text = "";
        }

        else {
            if (hasStarted) {
                finalText.text = "";
            } else {
                finalText.text = "COLLECT ALL PADS";
                finalText.x = (window.innerWidth - finalText.width) / 2;
            }
            statusText.text =
                "PADS: " + padsRemaining + "\n"
                + "HEALTH: " + hero.hitPoints + "\n"
                + "SHIELD: " + hero.shieldHitPoints + "\n";
        }
        rendererPixi.render(pixiStage, undefined, false);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        rendererThree.setSize(window.innerWidth, window.innerHeight);
        pixiStage.destroy(true);
        pixiStage = new PIXI.Container();
        init2d();
    }


</script>
<canvas id="screen"></canvas>
</body>
</html>
