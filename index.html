<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-title" content="SYNTH*BLAST"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1"/>
    <meta name="format-detection" content="telephone=no"/>
    <link rel="apple-touch-icon" sizes="150x150" href="img/apple-touch-icon.png">
    <title>S Y N T H * B L A S T</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            position: fixed;
            /*https://stackoverflow.com/questions/15829172/stop-chrome-back-forward-two-finger-swipe*/
            overscroll-behavior-x: none;
        }

        canvas {
            width: 100%;
            height: 100%;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            outline: none;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0); /* mobile webkit */
        }
    </style>
</head>
<body>
<script src='node_modules/stats.js/build/stats.min.js'></script>
<script type="module">



    // make synthwave background (syntywave sunset)
    // skybox: https://threejsfundamentals.org/threejs/lessons/threejs-backgrounds.html
    // skybox SO: https://stackoverflow.com/questions/45443196/how-to-set-up-image-background-in-three-js
    // https://videohive.net/item/80s-synthwave-retro-hd/24080448

    // add touch interface

    // add shooting stars

    // make guns things you can pick up

    // add glow / bloom

    // have to be facing an enemy to shoot them

    // make speeds adjust for framerate so we have consistent time



    // libraries
    import * as THREE from "./lib/three.module.js";
    // import * as PIXI from "./lib/pixi.js";
    import * as Utils from "./js/Utils.js";

    // classes
    import Hero from "./classes/Hero.js";
    import Building from "./classes/Building.js";
    import Gun from "./classes/Gun.js";
    import Enemy from "./classes/Enemy.js";

    let scene, camera, rendererThree;

    let paused = false;

    let hero = null;
    let bullets = [];
    let buildings = [];
    let enemies = [];
    let gun = null;

    let arenaSize = 100;

    // Sounds
    let massive = new Audio('audio/massive2.wav');
    let pew = new Audio('audio/pip.wav');
    let explosionSound = new Audio('audio/explosion2.wav');

    // Music
    // let song = new Audio('music/implant-128kbps.mp3');
    // song.crossOrigin = "anonymous";

    // State
    let isSongPlaying = false;

    // stats
    let stats = new Stats();
    stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
    document.body.appendChild(stats.dom);

    init();
    animate();

    // function loop() {
    //     rendererThree.state.reset();
    //     rendererThree.render(scene, camera);
    //     rendererThree.state.reset();
    //
    //     // rendererPixi.reset();
    //     // rendererPixi.render(stage, undefined, false);
    //     // rendererPixi.reset();
    // }


    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 50);
        const canvas = document.getElementById("screen");
        rendererThree = new THREE.WebGLRenderer({
            canvas: canvas
        });

        // scene.background = new THREE.Color(0xefd1b5);
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0xFF00FF, 0.05);
        scene.color = 0x00DD00;

        rendererThree.setSize(window.innerWidth, window.innerHeight);

        hero = new Hero(scene, camera, -10, 0);
        // add buildings
        for (let gridX = 0; gridX < arenaSize; gridX++) {
            for (let gridY = 0; gridY < arenaSize; gridY++) {
                if (Utils.randomInt(10) === 0) {
                    let boxHeight = Utils.randomInt(10) + 1;
                    let building = new Building(gridX, gridY - arenaSize / 2, boxHeight, scene);
                    buildings.push(building);
                } else if (Utils.randomInt(20) === 0) {
                    let enemy = new Enemy(gridX, gridY, scene, explosionSound);
                    enemies.push(enemy);
                }
            }
        }

        gun = new Gun(scene, bullets, hero, pew);
        hero.setGun(gun);

        // floor
        let floorTexture = new THREE.TextureLoader().load('img/floor-tile.png');
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(1000, 1000);
        let floorMaterial = new THREE.MeshBasicMaterial({map: floorTexture, side: THREE.FrontSide});
        let floorGeometry = new THREE.PlaneGeometry(1000, 1000, 1, 1);
        let plane = new THREE.Mesh(floorGeometry, floorMaterial);
        plane.position.z = 0;
        scene.add(plane);

        // light
        let dirLight;
        dirLight = new THREE.DirectionalLight(0xffffff);
        dirLight.position.set(-2, 5, 3).normalize();
        scene.add(dirLight);

        // helpers
        let axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        // listeners
        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('keydown', onDocumentKeyDown, false);
        document.addEventListener('keyup', onDocumentKeyUp, false);
        document.addEventListener('touchstart', touchStart, true);
        document.addEventListener('touchend', touchEnd, true);
        document.body.addEventListener('touchmove', touchStart, {passive: false});

    }

    function touchStart(event) {
        down(event);
        event.stopImmediatePropagation();
        event.preventDefault();
    }

    function touchEnd() {
        hero.stopTurning();
        hero.stop();
        hero.stopShooting();
    }

    function down(event) {
        let posX = event.touches[0].clientX;
        let posY = event.touches[0].clientY;
        let width = 50;
        let x1 = width;
        let x2 = width * 2;
        let x3 = width * 3;
        let y1 = window.innerHeight - width * 3;
        let y2 = window.innerHeight - width * 2;
        let y3 = window.innerHeight - width;

        // check that we're in the control box
        if (posX < x3 && posY > y1) {
            if (posX < x1) {
                hero.turnLeft();
            }
            if (posX > x1 && posX < x2) {
                hero.stopTurning();
            }
            if (posX > x2) {
                hero.turnRight();
            }
            if (posY < y2) {
                hero.forward();
            }
            if (posY > y2 && posY < y3) {
                hero.stop();
            }
            if (posY > y3) {
                hero.reverse();
            }
        }

        if (posX > window.innerWidth - 3 * width) {
            hero.startShooting();
        }
    }

    function onDocumentKeyDown(event) {
        let keyCode = event["which"];
        if (event.shiftKey) {
            hero.changePerspective();
        } else if (keyCode === 32) {
            hero.startShooting();
        } else if (keyCode === 37) {
            hero.turnLeft();
        } else if (keyCode === 38) {
            hero.forward();
        } else if (keyCode === 39) {
            hero.turnRight();
        } else if (keyCode === 40) {
            hero.reverse();
        }
    }

    function onDocumentKeyUp(event) {
        let keyCode = event["which"];
        if (keyCode === 32) {
            hero.stopShooting();
        } else if (keyCode === 37) {
            hero.stopTurning();
        } else if (keyCode === 38) {
            hero.stop();
        } else if (keyCode === 39) {
            hero.stopTurning();
        } else if (keyCode === 40) {
            hero.stop();
        }
    }

    function animate() {
        stats.begin();
        // TODO: try moving to end with other updates
        // update our objects
        bullets.forEach(bullet => bullet.update());
        buildings.forEach(building => building.update());
        enemies.forEach(enemy => enemy.update(hero));
        hero.update();
        // bullets hitting things
        bullets.forEach(bullet => {
            if (bullet.isActive()) {
                buildings.forEach(building => {
                    if (
                        building.isActive()
                        && Math.abs(building.getX() - bullet.getX()) < 0.5
                        && Math.abs(building.getY() - bullet.getY()) < 0.5
                    ) {
                        building.hit();
                        bullet.hit();

                    }
                });
                enemies.forEach(enemy => {
                    if (
                        enemy.isAlive()
                        && Math.abs(enemy.getX() - bullet.getX()) < 0.4
                        && Math.abs(enemy.getY() - bullet.getY()) < 0.4
                    ) {
                        enemy.hit();
                        bullet.hit();
                    }
                });

            }
        });

        // can't go through buildings
        buildings.forEach(building => {
            if (building.isActive()) {
                if (
                    Math.abs(building.getX() - hero.getX()) < 0.6
                    && Math.abs(building.getY() - hero.getY()) < 0.6
                ) {
                    // mildly confusing, but direction already had a multiplySclar earlier.
                    // this reversing that
                    hero.unMove();
                }
                enemies.forEach(
                    enemy => {
                        if (
                            enemy.isAlive()
                            && Math.abs(enemy.getX() - building.getX()) < 0.6
                            && Math.abs(enemy.getY() - building.getY()) < 0.6
                        ) {
                            enemy.unMove();
                        }
                    });
            }
        });

        enemies.forEach(
            enemy => {
                if (
                    enemy.isAlive()
                    && Math.abs(enemy.getX() - hero.getX()) < 0.4
                    && Math.abs(enemy.getY() - hero.getY()) < 0.4
                ) {
                    hero.reset();
                }
            });



        stats.end();
        requestAnimationFrame(animate);
        rendererThree.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        rendererThree.setSize(window.innerWidth, window.innerHeight);
    }



</script>
<canvas id="screen"></canvas>
</body>
</html>
