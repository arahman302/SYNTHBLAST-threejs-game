<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-title" content="SYNTH*BLAST"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1"/>
    <meta name="format-detection" content="telephone=no"/>
    <link rel="apple-touch-icon" sizes="150x150" href="img/apple-touch-icon.png">
    <title>S Y N T H * B L A S T</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            position: fixed;
            /*https://stackoverflow.com/questions/15829172/stop-chrome-back-forward-two-finger-swipe*/
            overscroll-behavior-x: none;
        }

        canvas {
            width: 100%;
            height: 100%;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            outline: none;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0); /* mobile webkit */
        }
    </style>
</head>
<body>
<script src='node_modules/stats.js/build/stats.min.js'></script>
<script src='lib/pixi.min.js'></script>
<script type="module">


    // make synthwave background (syntywave sunset)
    // skybox: https://threejsfundamentals.org/threejs/lessons/threejs-backgrounds.html
    // skybox SO: https://stackoverflow.com/questions/45443196/how-to-set-up-image-background-in-three-js
    // https://videohive.net/item/80s-synthwave-retro-hd/24080448

    // add touch interface

    // add shooting stars

    // make guns things you can pick up

    // add glow / bloom

    // have to be facing an enemy to shoot them

    // make speeds adjust for framerate so we have consistent time

    // add UI elements: health bar

    // handle multitouch shoot and fire


    // libraries
    import * as THREE from "./lib/three.module.js";
    // import * as PIXI from "./lib/pixi.min.js";
    import * as Utils from "./js/Utils.js";

    // classes
    import Hero from "./js/classes/Hero.js";
    import Building from "./js/classes/Building.js";
    import Gun from "./js/classes/Gun.js";
    import Enemy from "./js/classes/Enemy.js";

    let scene, camera, rendererThree, rendererPixi, pixiStage;

    let hero = null;
    let bullets = [];
    let buildings = [];
    let enemies = [];
    let gun = null;

    let arenaSize = 100;

    // Sounds
    let massive = new Audio('audio/massive2.wav');
    let pew = new Audio('audio/pip.wav');
    let explosionSound = new Audio('audio/explosion2.wav');

    // Music
    // let song = new Audio('music/implant-128kbps.mp3');
    // song.crossOrigin = "anonymous";

    // State
    let isSongPlaying = false;

    // stats
    let stats = new Stats();
    stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
    document.body.appendChild(stats.dom);

    init();
    animate();

    function animate() {
        stats.begin();
        rendererThree.state.reset();
        render3d();
        rendererThree.state.reset();

        rendererPixi.reset();
        render2d();
        rendererPixi.reset();

        stats.end();
        requestAnimationFrame(animate);
    }

    // custom game loop: https://github.com/pixijs/pixi.js/wiki/v5-Custom-Application-GameLoop
    function render2d() {



        rendererPixi.render(pixiStage, undefined, false);
    }



    function init() {
        const canvas = document.getElementById("screen");
        rendererThree = new THREE.WebGLRenderer({
            canvas: canvas
        });
        rendererPixi = new PIXI.Renderer({
            view: canvas,
            context: rendererThree.getContext()
        });
        pixiStage = new PIXI.Container();

        init3d();
        init2d();

        // listeners
        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('keydown', onDocumentKeyDown, false);
        document.addEventListener('keyup', onDocumentKeyUp, false);
        document.addEventListener('touchstart', touchStart, {passive: false});
        document.addEventListener('touchend', touchEnd, {passive: false});
        document.body.addEventListener('touchmove', touchStart, {passive: false});
    }

    function init2d() {
        // let rectangle = new PIXI.Graphics();
        // rectangle.lineStyle(4, 0xFF3300, 1);
        // rectangle.beginFill(0x66CCFF);
        // rectangle.drawRect(0, 0, 64, 64);
        // rectangle.endFill();
        // // rectangle.x = 170;
        // // rectangle.y = 170;
        // pixiStage.addChild(rectangle);
        //
        // let style = new PIXI.TextStyle({
        //     fontFamily: "Arial",
        //     fontSize: 36,
        //     fill: "white",
        //     stroke: '#ff00FF',
        //     strokeThickness: 4,
        //     dropShadow: true,
        //     dropShadowColor: "#000000",
        //     dropShadowBlur: 2,
        //     dropShadowAngle: 0,
        //     dropShadowDistance: 0,
        // });
        // let message = new PIXI.Text("S  Y  N  T  H  *  B  L  A  S  T", style);
        // message.position.set(54, 96);
        // pixiStage.addChild(message);

        let width = 50;
        let offset = 10;
        let x0 = offset;
        let x1 = width + offset;
        let x2 = width * 2 + offset;
        let x3 = width * 3 + offset;

        let y1 = window.innerHeight - width * 3 - offset;
        let y2 = window.innerHeight - width * 2 - offset;
        let y3 = window.innerHeight - width - offset;
        let y4 = window.innerHeight - offset;

        drawLine(x0, y1, x3, y1);
        drawLine(x0, y2, x3, y2);
        drawLine(x0, y3, x3, y3);
        drawLine(x0, y4, x3, y4);
        drawLine(x0, y1, x0, y4);
        drawLine(x1, y1, x1, y4);
        drawLine(x2, y1, x2, y4);
        drawLine(x3, y1, x3, y4);
    }

    function drawLine(x1, y1, x2, y2) {
        let line = new PIXI.Graphics();
        line.lineStyle(1, 0xAA00AA, 1);
        line.moveTo(x1, y1);
        line.lineTo(x2, y2);
        pixiStage.addChild(line);
    }

    function init3d() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 50);
        scene.background = new THREE.Color(0x000000);
        // scene.background = new THREE.Color(0xefd1b5);
        scene.fog = new THREE.FogExp2(0xFF00FF, 0.05);
        scene.color = 0x00DD00;

        rendererThree.setSize(window.innerWidth, window.innerHeight);

        hero = new Hero(scene, camera, -10, 0);
        // add buildings
        for (let gridX = 0; gridX < arenaSize; gridX++) {
            for (let gridY = 0; gridY < arenaSize; gridY++) {
                if (Utils.randomInt(20) === 0) {
                    let boxHeight = Utils.randomInt(10) + 1;
                    let building = new Building(gridX, gridY - arenaSize / 2, boxHeight, scene);
                    buildings.push(building);
                } else if (Utils.randomInt(40) === 0) {
                    let enemy = new Enemy(gridX, gridY, scene, explosionSound);
                    enemies.push(enemy);
                }
            }
        }

        gun = new Gun(scene, bullets, hero, pew);
        hero.setGun(gun);

        // floor
        let floorTexture = new THREE.TextureLoader().load('img/floor-tile.png');
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(1000, 1000);
        let floorMaterial = new THREE.MeshBasicMaterial({map: floorTexture, side: THREE.FrontSide});
        let floorGeometry = new THREE.PlaneGeometry(1000, 1000, 1, 1);
        let plane = new THREE.Mesh(floorGeometry, floorMaterial);
        plane.position.z = 0;
        scene.add(plane);

        // light
        let dirLight;
        dirLight = new THREE.DirectionalLight(0xffffff);
        dirLight.position.set(-2, 5, 3).normalize();
        scene.add(dirLight);

        // helpers
        let axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);
    }

    function touchStart(event) {
        down(event);
        event.stopImmediatePropagation();
        event.preventDefault();
    }

    function touchEnd() {
        hero.stopTurning();
        hero.stop();
        hero.stopShooting();
    }

    function down(event) {
        let posX = event.touches[0].clientX;
        let posY = event.touches[0].clientY;
        let width = 50;
        let x1 = width;
        let x2 = width * 2;
        let x3 = width * 3;
        let y1 = window.innerHeight - width * 3;
        let y2 = window.innerHeight - width * 2;
        let y3 = window.innerHeight - width;

        // check that we're in the control box
        if (posX < x3 && posY > y1) {
            if (posX < x1) {
                hero.turnLeft();
            }
            if (posX > x1 && posX < x2) {
                hero.stopTurning();
            }
            if (posX > x2) {
                hero.turnRight();
            }
            if (posY < y2) {
                hero.forward();
            }
            if (posY > y2 && posY < y3) {
                hero.stop();
            }
            if (posY > y3) {
                hero.reverse();
            }
        }

        if (posX > window.innerWidth - 3 * width) {
            hero.startShooting();
        }
    }

    function onDocumentKeyDown(event) {
        let keyCode = event["which"];
        if (event.shiftKey) {
            hero.changePerspective();
        } else if (keyCode === 32) {
            hero.startShooting();
        } else if (keyCode === 37) {
            hero.turnLeft();
        } else if (keyCode === 38) {
            hero.forward();
        } else if (keyCode === 39) {
            hero.turnRight();
        } else if (keyCode === 40) {
            hero.reverse();
        }
    }

    function onDocumentKeyUp(event) {
        let keyCode = event["which"];
        if (keyCode === 32) {
            hero.stopShooting();
        } else if (keyCode === 37) {
            hero.stopTurning();
        } else if (keyCode === 38) {
            hero.stop();
        } else if (keyCode === 39) {
            hero.stopTurning();
        } else if (keyCode === 40) {
            hero.stop();
        }
    }

    function render3d() {

        // update our objects
        bullets.forEach(bullet => bullet.update());
        buildings.forEach(building => building.update());
        enemies.forEach(enemy => enemy.update(hero));
        hero.update();

        // bullets hitting things
        bullets.forEach(bullet => {
            if (bullet.isActive()) {
                buildings.forEach(building => {
                    if (
                        building.isActive()
                        && Math.abs(building.getX() - bullet.getX()) < 0.5
                        && Math.abs(building.getY() - bullet.getY()) < 0.5
                    ) {
                        building.hit();
                        bullet.hit();

                    }
                });
                enemies.forEach(enemy => {
                    if (
                        enemy.isAlive()
                        && Math.abs(enemy.getX() - bullet.getX()) < 0.4
                        && Math.abs(enemy.getY() - bullet.getY()) < 0.4
                    ) {
                        enemy.hit();
                        bullet.hit();
                    }
                });

            }
        });

        // can't go through buildings
        buildings.forEach(building => {
            if (building.isActive()) {
                if (
                    Math.abs(building.getX() - hero.getX()) < 0.6
                    && Math.abs(building.getY() - hero.getY()) < 0.6
                ) {
                    // mildly confusing, but direction already had a multiplySclar earlier.
                    // this reversing that
                    hero.unMove();
                }
                enemies.forEach(
                    enemy => {
                        if (
                            enemy.isAlive()
                            && Math.abs(enemy.getX() - building.getX()) < 0.6
                            && Math.abs(enemy.getY() - building.getY()) < 0.6
                        ) {
                            enemy.unMove();
                        }
                    });
            }
        });

        enemies.forEach(
            enemy => {
                if (
                    enemy.isAlive()
                    && Math.abs(enemy.getX() - hero.getX()) < 0.4
                    && Math.abs(enemy.getY() - hero.getY()) < 0.4
                ) {
                    // hero.reset();
                }
            });

        rendererThree.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        rendererThree.setSize(window.innerWidth, window.innerHeight);
    }


</script>
<canvas id="screen"></canvas>
</body>
</html>
